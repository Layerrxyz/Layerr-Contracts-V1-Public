{
	"language": "Solidity",
	"sources": {
		"contracts/LayerrWallet.sol": {
			"content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @title LayerrWallet\r\n * @author 0xth0mas (Layerr)\r\n * @notice A multi-sig smart contract wallet with support for\r\n *         both transactions that are chain-specific and \r\n *         transactions that are replayable on all chains that\r\n *         the contract is deployed on.\r\n */\r\ncontract LayerrWallet {\r\n\r\n    /// @dev Defines call parameters for transactions \r\n    struct Call {\r\n        uint256 nonce;\r\n        address to;\r\n        uint256 value;\r\n        bytes data;\r\n        uint256 gas;\r\n    }\r\n\r\n    /// @dev Thrown when non-address(this) attempts to call external functions that must be called from address(this)\r\n    error InvalidCaller();\r\n\r\n    /// @dev Thrown when signatures are supplied out of order, signatures must be supplied in ascending signer id order\r\n    error SignaturesOutOfOrder();\r\n\r\n    /// @dev Thrown when attempting to add a signer that already exists\r\n    error AddressAlreadySigner();\r\n\r\n    /// @dev Thrown when attempting to remove an address that is not currently a signer\r\n    error AddressNotSigner();\r\n\r\n    /**\r\n     *  @dev Thrown when remove signer/threshold update would make it impossible to execute a transaction\r\n     *       or when a transaction is submitted without enough signatures to meet the threshold.\r\n     */\r\n    error NotEnoughSigners();\r\n\r\n    /// @dev Thrown when the supplied call's nonce is not the current nonce for the contract\r\n    error InvalidNonce();\r\n\r\n    /// @dev Thrown when attempting to call the add/remove signer and threshold functions with a chain-specific call\r\n    error CannotCallSelf();\r\n\r\n    /// @dev Thrown when the call results in a revert\r\n    error CallFailed(); \r\n\r\n    /// @dev Emitted when removing a signer\r\n    event SignerRemoved(address indexed signer);\r\n    /// @dev Emitted when adding a signer\r\n    event SignerAdded(address indexed signer, uint256 indexed signerId);\r\n\r\n    bytes32 constant EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    bytes32 constant CHAINLESS_EIP712_DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,address verifyingContract)\"\r\n    );\r\n\r\n    bytes32 constant CALL_TYPEHASH = keccak256(\r\n        \"Call(uint256 nonce,address to,uint256 value,bytes data,uint256 gas)\"\r\n    );\r\n\r\n    bytes32 private immutable _cachedDomainSeparator;\r\n    bytes32 private immutable _cachedChainlessDomainSeparator;\r\n    uint256 private immutable _cachedChainId;\r\n    address private immutable _cachedThis;\r\n\r\n    string private constant _name = \"LayerrWallet\";\r\n    string private constant _version = \"1.0\";\r\n\r\n    bytes32 private immutable _hashedName;\r\n    bytes32 private immutable _hashedVersion;\r\n\r\n    /// @dev mapping of signer addresses to their id, addresses with id of 0 are not valid signers\r\n    mapping(address => uint256) public signerIds;\r\n\r\n    /// @dev the minimum number of valid signatures to execute a transaction\r\n    uint32 public minimumSignatures;\r\n\r\n    /// @dev the number of signers that are currently authorized to sign a transaction\r\n    uint32 public currentSigners;\r\n\r\n    /// @dev the current nonce for transactions that can only be executed on a specific chain\r\n    uint32 public chainCallNonce;\r\n\r\n    /// @dev the current nonce for transactions that can be executed across all chains\r\n    uint32 public chainlessCallNonce;\r\n\r\n    /// @dev the signer id that will be given to the next signer added\r\n    uint32 private nextSignerId;\r\n\r\n    constructor() {\r\n        _hashedName = keccak256(bytes(_name));\r\n        _hashedVersion = keccak256(bytes(_version));\r\n\r\n        _cachedChainId = block.chainid;\r\n        _cachedDomainSeparator = _buildDomainSeparator();\r\n        _cachedChainlessDomainSeparator = _buildChainlessDomainSeparator();\r\n        _cachedThis = address(this);\r\n\r\n        signerIds[0x3A366622378D846E8Fcee6F06F2f199Fb3349e9d] = 1;\r\n        signerIds[0x1602B3707A9213A313bc21337Ae93c947b4929B4] = 2;\r\n        signerIds[0x1C535EC3b6A2952eD9c8459d0a5A682aC847092D] = 3;\r\n        signerIds[0x3C5E6B4292Ed35e8973400bEF77177A9e84e8E6e] = 4;\r\n        currentSigners = 4;\r\n        nextSignerId = 5;\r\n        minimumSignatures = 2;\r\n    }\r\n\r\n    /**\r\n     * @notice Chainless calls are not chain specific and can be replayed on any chain\r\n     *         that the contract is deployed to.\r\n     * @dev This is intended to be used for protocol updates that need to be applied \r\n     *      across all chains.\r\n     * @param call struct containing the details of the call transaction to execute\r\n     * @param signatures signatures to validate the call\r\n     */\r\n    function chainlessCall(Call calldata call, bytes[] calldata signatures) external {\r\n        if(call.nonce != chainlessCallNonce) revert InvalidNonce();\r\n\r\n        bytes32 callDigest = _getChainlessCallSignatureDigest(_getCallHash(call));\r\n\r\n        uint256 lastSignerId;\r\n        uint256 currentSignerId;\r\n        uint256 validSignatures;\r\n\r\n        for(uint256 signatureIndex;signatureIndex < signatures.length;) {\r\n            currentSignerId = signerIds[_recoverCallSigner(callDigest, signatures[signatureIndex])];\r\n            if(currentSignerId <= lastSignerId) revert SignaturesOutOfOrder();\r\n            lastSignerId = currentSignerId;\r\n\r\n            unchecked {\r\n                ++validSignatures;\r\n                ++signatureIndex;\r\n            }\r\n        }\r\n\r\n        if(validSignatures < minimumSignatures) revert NotEnoughSigners();\r\n        unchecked { ++chainlessCallNonce; }\r\n\r\n        if(!_execute(call.to, call.value, call.data, call.gas)) { revert CallFailed(); }\r\n    }\r\n\r\n    /**\r\n     * @notice Chain calls are chain specific and cannot be replayed to other chains.\r\n     * @dev This is intended to be used for transactions that are chain-specific \r\n     *      such as treasury management where values and addresses that values are being\r\n     *      sent to may differ from chain to chain.\r\n     * @param call struct containing the details of the call transaction to execute\r\n     * @param signatures signatures to validate the call\r\n     */\r\n    function chainCall(Call calldata call, bytes[] calldata signatures) external {\r\n        if(call.nonce != chainCallNonce) revert InvalidNonce();\r\n        if(call.to == address(this)) revert CannotCallSelf();\r\n\r\n        bytes32 callDigest = _getCallSignatureDigest(_getCallHash(call));\r\n\r\n        uint256 lastSignerId;\r\n        uint256 currentSignerId;\r\n        uint256 validSignatures;\r\n\r\n        for(uint256 signatureIndex;signatureIndex < signatures.length;) {\r\n            currentSignerId = signerIds[_recoverCallSigner(callDigest, signatures[signatureIndex])];\r\n            if(currentSignerId <= lastSignerId) revert SignaturesOutOfOrder();\r\n            lastSignerId = currentSignerId;\r\n\r\n            unchecked {\r\n                ++validSignatures;\r\n                ++signatureIndex;\r\n            }\r\n        }\r\n\r\n        if(validSignatures < minimumSignatures) revert NotEnoughSigners();\r\n        unchecked { ++chainCallNonce; }\r\n\r\n        if(!_execute(call.to, call.value, call.data, call.gas)) { revert CallFailed(); }\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a signer to the smart contract wallet\r\n     * @dev This increments the number of current signers but does not change thresholds\r\n     * @param signer address to add as a valid signer\r\n     */\r\n    function addSigner(address signer) external {\r\n        if(msg.sender != address(this)) revert InvalidCaller();\r\n        if(signerIds[signer] > 0) revert AddressAlreadySigner();\r\n\r\n        uint256 newSignerId = nextSignerId;\r\n        signerIds[signer] = newSignerId;\r\n\r\n        unchecked {\r\n            ++currentSigners;\r\n            ++nextSignerId;\r\n        }\r\n\r\n        emit SignerAdded(signer, newSignerId);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a signer from the smart contract wallet\r\n     * @dev This decreases the number of current signers and validates that it will\r\n     *      not create a situation where the threshold is greater than current signers\r\n     * @param signer address to be removed as a signer\r\n     */\r\n    function removeSigner(address signer) external {\r\n        if(msg.sender != address(this)) revert InvalidCaller();\r\n        if(signerIds[signer] == 0) revert AddressNotSigner();\r\n\r\n        signerIds[signer] = 0;\r\n\r\n        unchecked {\r\n            --currentSigners;\r\n        }\r\n\r\n        if(minimumSignatures > currentSigners) revert NotEnoughSigners();\r\n\r\n        emit SignerRemoved(signer);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the minimum number of signatures to execute a transaction\r\n     * @dev This enforces minimum signatures > 0 and current signers > minimum\r\n     * @param _minimumSignatures the threshold of valid signatures to execute a transaction\r\n     */\r\n    function setMinimumSignatures(uint256 _minimumSignatures) external {\r\n        if(msg.sender != address(this)) revert InvalidCaller();\r\n\r\n        if(_minimumSignatures == 0) revert NotEnoughSigners();\r\n        if(_minimumSignatures > currentSigners) revert NotEnoughSigners();\r\n\r\n        minimumSignatures = uint32(_minimumSignatures);\r\n    }\r\n\r\n    function _execute(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        uint256 gasAmount\r\n    ) internal returns (bool success) {\r\n        assembly {\r\n            if iszero(gasAmount) {\r\n                gasAmount := gas()\r\n            }\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, data.offset, data.length)\r\n            success := call(gasAmount, to, value, ptr, data.length, 0, 0)\r\n        }\r\n    }\r\n    \r\n    function _recoverCallSigner(\r\n        bytes32 digest,\r\n        bytes calldata signature\r\n    ) internal pure returns (address signer) {\r\n        signer = _recover(digest, signature);\r\n    }\r\n\r\n    function _getCallSignatureDigest(bytes32 callHash) internal view returns (bytes32 digest) {\r\n        digest = keccak256(\r\n            abi.encodePacked(\"\\x19\\x01\", _domainSeparator(), callHash)\r\n        );\r\n    }\r\n\r\n    function _getChainlessCallSignatureDigest(bytes32 callHash) internal view returns (bytes32 digest) {\r\n        digest = keccak256(\r\n            abi.encodePacked(\"\\x19\\x01\", _chainlessDomainSeparator(), callHash)\r\n        );\r\n    }\r\n\r\n    function _getCallHash(\r\n        Call calldata call\r\n    ) internal pure returns (bytes32 hash) {\r\n        bytes memory encoded = abi.encode(\r\n            CALL_TYPEHASH,\r\n            call.nonce,\r\n            call.to,\r\n            call.value,\r\n            keccak256(call.data),\r\n            call.gas\r\n        );\r\n        hash = keccak256(encoded);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the domain separator for the current chain.\r\n     */\r\n    function _domainSeparator() private view returns (bytes32 separator) {\r\n        separator = _cachedDomainSeparator;\r\n        if (_cachedDomainSeparatorInvalidated()) {\r\n            separator = _buildDomainSeparator();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the chainless domain separator.\r\n     */\r\n    function _chainlessDomainSeparator() private view returns (bytes32 separator) {\r\n        separator = _cachedChainlessDomainSeparator;\r\n        if (_cachedDomainSeparatorInvalidated()) {\r\n            separator = _buildChainlessDomainSeparator();\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Returns if the cached domain separator has been invalidated.\r\n     */ \r\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\r\n        uint256 cachedChainId = _cachedChainId;\r\n        address cachedThis = _cachedThis;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\r\n        }\r\n    }\r\n\r\n    function _buildDomainSeparator() private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    EIP712_DOMAIN_TYPEHASH,\r\n                    _hashedName,\r\n                    _hashedVersion,\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    function _buildChainlessDomainSeparator() private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    CHAINLESS_EIP712_DOMAIN_TYPEHASH,\r\n                    _hashedName,\r\n                    _hashedVersion,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Recover signer address from a message by using their signature\r\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n     * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n     */\r\n    function _recover(\r\n        bytes32 hash,\r\n        bytes calldata sig\r\n    ) internal pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r := calldataload(sig.offset)\r\n            s := calldataload(add(sig.offset, 32))\r\n            v := byte(0, calldataload(add(sig.offset, 64)))\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    fallback() external payable { }\r\n    receive() external payable { }\r\n}"
		}
	},
	"settings": {
		"optimizer": {
			"enabled": true,
			"runs": 33333
		},
		"evmVersion": "paris",
		"viaIR": true,
		"outputSelection": {
			"*": {
				"*": [
					"abi",
					"evm.bytecode",
					"evm.deployedBytecode",
					"evm.methodIdentifiers",
					"metadata"
				],
				"": [
					"ast"
				]
			}
		}
	}
}